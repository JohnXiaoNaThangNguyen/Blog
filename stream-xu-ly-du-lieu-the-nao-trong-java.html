<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Stream Xử Lý Dữ Liệu Thế Nào Trong Java - Blog</title><meta name="description" content="Sự ra đời của Java 8 đã làm thay đổi thói quen sử dụng của nhiều người lập trình đối với các Collection so với&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://johnxiaonathangnguyen.github.io/Blog/stream-xu-ly-du-lieu-the-nao-trong-java.html"><link rel="alternate" type="application/atom+xml" href="https://johnxiaonathangnguyen.github.io/Blog/feed.xml"><link rel="alternate" type="application/json" href="https://johnxiaonathangnguyen.github.io/Blog/feed.json"><meta property="og:title" content="Stream Xử Lý Dữ Liệu Thế Nào Trong Java"><meta property="og:site_name" content="Blog"><meta property="og:description" content="Sự ra đời của Java 8 đã làm thay đổi thói quen sử dụng của nhiều người lập trình đối với các Collection so với&hellip;"><meta property="og:url" content="https://johnxiaonathangnguyen.github.io/Blog/stream-xu-ly-du-lieu-the-nao-trong-java.html"><meta property="og:type" content="article"><link rel="preload" href="https://johnxiaonathangnguyen.github.io/Blog/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://johnxiaonathangnguyen.github.io/Blog/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://johnxiaonathangnguyen.github.io/Blog/assets/css/style.css?v=52c74cd382f8d89e5756730ae748a6f7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://johnxiaonathangnguyen.github.io/Blog/stream-xu-ly-du-lieu-the-nao-trong-java.html"},"headline":"Stream Xử Lý Dữ Liệu Thế Nào Trong Java","datePublished":"2024-12-29T20:52+07:00","dateModified":"2024-12-29T20:53+07:00","description":"Sự ra đời của Java 8 đã làm thay đổi thói quen sử dụng của nhiều người lập trình đối với các Collection so với&hellip;","author":{"@type":"Person","name":"nguyenducthang","url":"https://johnxiaonathangnguyen.github.io/Blog/authors/nguyenducthang/"},"publisher":{"@type":"Organization","name":"nguyenducthang"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://johnxiaonathangnguyen.github.io/Blog/">Blog</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li class="profile-page"><a href="https://johnxiaonathangnguyen.github.io/Blog/profile-page.html" target="_self">Home</a></li><li><a href="https://johnxiaonathangnguyen.github.io/Blog/tags/blog/" target="_self">Blog</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Stream Xử Lý Dữ Liệu Thế Nào Trong Java</h1><div class="post__meta"><time datetime="2024-12-29T20:52" class="post__date">December 29, 2024 </time><span class="post__author"><a href="https://johnxiaonathangnguyen.github.io/Blog/authors/nguyenducthang/" class="feed__author">nguyenducthang</a></span></div><div class="post__tags"><a href="https://johnxiaonathangnguyen.github.io/Blog/tags/blog/" class="invert">Bài viết của tôi</a></div></header><div class="post__entry"><p><strong>Sự ra đời của Java 8 đã làm thay đổi thói quen sử dụng của nhiều người lập trình đối với các Collection so với các phiên bản Java trước. Một trong những điều mới mẻ nhất chính là thêm các phương thức mở rộng vào các interface có sẵn (Collection, List, Iterable) cùng các lớp abstraction như Stream để thực hiện các phép toán tổng hợp trên tập dữ liệu và không làm thay đổi dữ liệu cũ. Trong bài viết này chúng ta sẽ tìm hiểu về Stream là gì và các đặc điểm của nó.</strong></p><ol><li><strong>Stream là gì?</strong></li></ol><p>Stream được giới thiệu từ bản <a href="https://codelearn.io/sharing/tao-chuong-trinh-java-don-gian-voi-jdk">java</a> 8 và được nằm trong gói java.util.stream. Stream đại diện cho một chuỗi các giá trị và phục vụ nhiều chức năng tổng hợp để thao tác với dữ liệu như duyệt, tìm giá trị lớn (bé) nhất, sorting, filter, hay limit. Stream có rất nhiều methods đa dạng và chúng có thể được kết hợp với nhau, một vài trong số chúng trả về kiểu Stream được gọi là intermediate operations và một số khác trả về kiểu non-stream(int, long, list, arrays,…) được gọi là terminal operations.</p><p>Một ví dụ là khi bạn muốn sắp xếp các giá trị trong một mảng thì thay vì phải viết các vòng lặp for hoặc while, bạn chỉ cần dùng một hay một vài phương thức của stream một cách ngắn gọn và đơn giản.</p><p><strong>Các tính chất của Stream:</strong></p><ul><li>Stream không phải là một cấu trúc dữ liệu, đầu vào của Stream có thể là các Colllections (<a href="https://codelearn.io/sharing/tai-sao-nen-dung-arraylist">Arraylist</a>, Set, <a href="https://codelearn.io/sharing/khac-biet-giua-array-linkedlist">LinkedList</a>,…), Arrays và các kênh Input/Output.</li><li>Stream không làm thay đổi dữ liệu gốc mà chỉ trả về kết quả thông qua các methods.</li><li>Về cơ bản các method của stream được phân làm 2 loại là hoạt động trung gian(Intermediate Operation) và hoạt động đầu cuối(Terminal Operation).</li></ul><p>Sau đây là một ví dụ về Stream:</p><p><code>Collection&lt;Integer&gt; collection = Arrays.asList(1,2,3);</code></p><p><code>Stream&lt;Integer&gt; streamOfCollection = collection.stream();</code></p><ol start="2"><li><strong>Các methods trong Stream</strong></li></ol><p><strong>2.1 Terminal Operations</strong></p><p>Các hoạt động đầu cuối này gồm các method có kiểu trả về khác stream như kiểu nguyên thủy(primitive), đối tượng(String, Integer,…) hay collections.</p><p><strong>Collect</strong> method: Dùng để trả về kết quả của stream dưới dạng List hoặc Set.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;String&gt; strings = Arrays.asList("args", "", "code", "learn", "...");</code></p><p><code>      List&lt;String&gt; filter = strings.stream().collect(Collectors.toList());</code></p><p><code>      System.out.println(filter);</code></p><p><code>  }</code></p><p>Ouput:</p><p><code><strong>forEach</strong> method: Dùng để duyệt qua mọi phần tử trong stream.</code></p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;String&gt; strings = Arrays.asList("args", "", "code", "learn", "...");</code></p><p><code>      strings.stream().forEach(s -&gt; System.out.println(s));</code></p><p><code>  }</code></p><p>Output:</p><p> </p><p><strong>Reduce</strong> method: Reduce() method với 1 trong 2 tham số truyền vào là method reference, dùng dể kết hợp các phần tử thành một giá trị đơn cùng kiểu với dữ liệu ban đầu.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;String&gt; strings = Arrays.asList("args", "", "code", "learn", "...");</code></p><p><code>      String result = strings.stream().reduce("-", String::concat);</code></p><p><code>      System.out.println(result);</code></p><p><code>  }</code></p><p>Tham số đầu tiên là chỉ giá trị ban đầu, tham số thứ hai là một method reference String::concat nhằm mục đích ghép các phần tử của Stream với nhau.</p><p>Output:</p><p><strong>Max, Min</strong> method: Trả về giá trị lớn nhất hoặc bé nhất trong các phần tử.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);</code></p><p><code>      Integer maxx = list.stream().max(Integer::compare).get();</code></p><p><code>      Integer minn = list.stream().min(Integer::compare).get();</code></p><p><code>      System.out.println("Max: "+maxx+"\nMin: "+minn);</code></p><p><code>  }</code></p><p>Output:</p><p><strong>2.2 Intermediate Operations</strong></p><p>Mỗi hoạt động trung gian này được thực thi một cách riêng biệt và có kết quả trả về cũng là một Stream do đó ta có thể kết hợp nhiều intermediate methods với nhau. Sau đây là một vài intermediate method:</p><p><strong>Distinct</strong> method: Được dùng để loại bỏ các phần tử trùng lặp.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(1,2,2,2,2,3,4,5);</code></p><p><code>      list.stream().distinct().forEach(System.out::println);</code></p><p><code>  }</code></p><p>Output: các số 2 trùng lặp đã được loại bỏ</p><p><strong>Map</strong> method: Map method được sử dụng để trả về một stream mà ở đó các phần tử đã  được thay đổi theo cách người dùng tự định nghĩa.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(1,2,2,2,2,3,4,5);</code></p><p><code>      list.stream().distinct().map(i -&gt; i*i).forEach(System.out::println);</code></p><p><code>  }</code></p><p>Output: bình phương của các phần tử</p><p><strong>Filter</strong> method: Dùng để lọc và xóa bỏ các phần tử với điều kiện do người dùng định nghĩa.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(1,2,2,2,2,3,4,5);</code></p><p><code>      list.stream().distinct().map(i-&gt;i*i).forEach(System.out::println);</code></p><p> </p><p><code>  }</code></p><p>Output: các phần tử lớn hơn 2</p><p><strong>Sorted</strong> method: Dùng cho việc sắp xếp các phần tử.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(4,3,2,1,0,3,4,5);</code></p><p><code>      list.stream().sorted().forEach(System.out::println);</code></p><p><code>  }</code></p><p>Output: các phần tử được sắp xếp theo thứ tự tăng dần.</p><p><strong>Limit</strong> method: limit(n) với tham số đầu vào là số nguyên không âm n nó sẽ trả về một stream chứa n phần tử đầu tiên.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;Integer&gt; list = Arrays.asList(4,3,2,1,0,3,4,5);</code></p><p><code>      list.stream().limit(3).forEach(System.out::println);</code></p><p><code>  }</code></p><p>Output: lấy ra 3 phần tử đầu tiên.</p><p><strong>Skip</strong> method: skip(n) với tham số truyền vào là số nguyên không âm n nó sẽ trả về các phần tử còn lại đằng sau n phần tử đầu tiên.</p><p>    <code>List&lt;Integer&gt; list = Arrays.asList(4,3,2,1,0,3,4,5);</code></p><p><code>      list.stream().skip(3).forEach(System.out::println);</code></p><p><code>  }</code></p><p>Output: In ra các phần tử trừ 3 phần tử đầu tiên.</p><ol start="3"><li><strong>Parallel Stream</strong></li></ol><p>ParallelStream là một sự thay thế của stream để phục vụ cho việc xử lý song song các phần tử. Kết quả của đoạn code sau thể hiện sự khác nhau giữa Stream và Parallel Stream.</p><p><code>public static void main(String[] args) {</code></p><p><code>      List&lt;String&gt; strings = Arrays.asList("code", "learn", "...");</code></p><p><code>      String streamString = strings.stream().reduce(" I'm-", String::concat);</code></p><p><code>      String parallelString = strings.parallelStream().reduce(" I'm-", String::concat);</code></p><p><code>      System.out.println("Stream: "+streamString +"\nParallelStream: "+parallelString);</code></p><p><code>  }</code></p><p>Output:</p><p>Các bạn có thể thấy rằng parallelStream() đã thực hiện intermediate method song song với tất cả các phần tử cùng một lúc nên trước các phần tử đều có chuỗi kí tự " I'm".</p><p><strong>Chú ý:</strong></p><ul><li>Thực chất các intermediate method không hoạt động khi chúng ta gọi đến mà chỉ thực thi khi có một terminal method kết thúc stream của nó.</li><li>Một luồng hay một stream có thể không có hoặc có nhiều intermediate method kết hợp với nhau nhưng chỉ bao gồm một terminal method để xử lý stream được trả về từ các intermediate method bên trên.</li><li>Stream được sử dụng để trả về kết quả các phần tử sau khi được xử lý thông qua các method mà không làm thay đổi giá trị các phần tử gốc.</li></ul><p><strong>Kết</strong></p><p>Qua bài viết mình và các bạn đã tìm hiểu qua về Stream trong java, thực tế stream còn rất nhiều ứng dụng khác mà các bạn có thể dễ dàng tìm hiểu thêm trên internet. Nếu bài viết có ý nghĩa hãy để lại đánh giá cũng như comment giúp phát triển bài viết tốt hơn. Cảm ơn bạn đọc!</p><p> </p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 29, 2024</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://johnxiaonathangnguyen.github.io/Blog/huong-dan-code-java-chuan-xac.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  HƯỚNG DẪN CODE JAVA CHUẨN XÁC "><span class="btn__icon">←</span> <span class="btn__text">HƯỚNG DẪN CODE JAVA CHUẨN XÁC</span> </a><a href="https://johnxiaonathangnguyen.github.io/Blog/java-debugging-cam-nang-go-loi-toan-tap.html" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  Java Debugging: Cẩm nang gỡ lỗi toàn tập "><span class="btn__text">Java Debugging: Cẩm nang gỡ lỗi toàn tập</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://johnxiaonathangnguyen.github.io/Blog/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>